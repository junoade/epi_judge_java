## CH5. 배열

### 체크목록
- 배열과 관련된 문제를 일단은 무식하게 접근하면, 공간 복잡도가 O(n)일 수 있다. 이 때 공간 복잡도를 O(1)로 줄이는 것은 어려울 수 있다. **문제 5.1 네덜란드 국기 문제**
- 배열을 앞에서부터 채워나가는 것이 비효율적일 때가 있다. 다시 말해 뒤에서 부터 채워가면 빠르게 풀 수도 있다. **문제 5.2 임의의 정수값 증가시키기**
- 원소를 삭제해서 다른 원소들을 왼쪽으로 옮기기보다는, 삭제할 원소에 덮어쓰는 방법이 나을 수도 있다. **문제 5.5 정렬된 배열에서 중복 제거하기**
- 배열로 표현된 정수를 다룰 때에는, 배열의 끝에서부터 숫자를 처리해 나가는 방법을 고려해보자. 혹은 배열을 뒤집어서 최하위 숫자를 배열의 첫 번째 위치에 오도록 만들 수도 있다. **문제 5.3 문제 임의의 두 정수값 곱하기**
- 부분 배열을 사용하는 코드를 작성하는 데 익숙해져라. **문제 5.11 다음 순열 구하기**
- 배열을 사용할 때 인덱스를 잘못 사용하는 실수를 조심하자. **문제 5.4 배열에서 이동하기 문제 5.18 2차원 배열에 나선형으로 원소 배치하기**
- 실제 반환할 때까지 배열의 초기 상태를 유지(정렬, 균등한 원소 유지) 하지 않아도 된다. **문제 5.5 정렬된 배열에서 중복 제거하기**
- 원소의 분포를 미리 알고 있을 때 배열은 좋은 자료구조가 될 수 있다.
  - 예를 들어, 길이가 W인 boolean 배열을 사용하면, 숫자 집합 {0,1, ..., W-1} 의 부분집합을 쉽게 표현할 수 있다(?)
  - {1,2,3,...,n})의 부분 집합을 boolean 배열로 표현할 때, 인덱스를 간단하게 크기가 n+1인 배열을 사용해도 된다(?) **문제 5.9 n보다 작은 모든 소수 나열하기**
- 2차원 배열을 사용할 때는, 열과 행을 동시에 처리하는 로직을 사용하라 **문제 5.18 2차원 배열에 나선형으로 원소 배치하기**
- 가끔은 문제의 세부 사항을 따라 해 보는 것이 문제를 분석적으로 푸는 것보다 쉬울 수 있다. 
  - 예를 들어 나선형으로 채워진 n*n 배열의 i번째 원소를 찾는 수식을 작성하는 것 보다, 
  - 첫 번째 원소부터 나선형으로 하나씩 따라가며, i번째 원소를 찾는게 더 쉬울 수 있다. **문제 5.18, 문제 5.20**
  
### 학습 기록
- 22/07/01
  - 배열 주요 개념 복습
    - 1차원, 2차원, 3차원 배열의 생성
    - deepcopy와 shallowcopy차이
    - Arrays 유틸리티
    > 대표적인 static 메소드 : asList(), binarySearch(), copyOf(), copyOfRange(), equals(), fill(), find(), sort(), toString() 등
    - Colletions에 대해



### 참고하면 좋은 링크


